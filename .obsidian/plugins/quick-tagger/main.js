/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuickTagPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/utilities.ts
var import_obsidian4 = require("obsidian");

// src/modal.ts
var import_obsidian = require("obsidian");

// src/constants.ts
var SPECIAL_COMMANDS = ["REMOVE ALL"];
var WOAH_LOTS_OF_FILES = 20;
var KNOWN_BAD_CHARACTERS = [
  "\u2012",
  "\u2013",
  "\u2014",
  "\u2015",
  "\u204F",
  "\u203D",
  "\u2018",
  "\u201A",
  "\u201B",
  "\u2039",
  "\u203A",
  "\u201C",
  "\u201D",
  "\u201E",
  "\u201F",
  "\u2045",
  "\u2046",
  "\u204B",
  "\u204E",
  "\u2051",
  "\u2044",
  "\u204A",
  "\u2030",
  "\u2031",
  "\u2052",
  "\u2020",
  "\u2021",
  "\u2022",
  "\u2023",
  "\u2043",
  "\u204C",
  "\u204D",
  "\u2032",
  "\u2035",
  "\u2038",
  "\u203B",
  "\u2050",
  "\u2041",
  "\u2042",
  "\u2016",
  "\u2011",
  "\u2033",
  "\u2034",
  "\u2057",
  "\u2036",
  "\u2037",
  "`",
  "^",
  "\u203E",
  "\u2017",
  "\u2053",
  ",",
  ";",
  ":",
  "!",
  "\u203C",
  "\u2049",
  "?",
  "\u2048",
  "\u2047",
  ".",
  "\u2024",
  "\u2025",
  "\u2026",
  "'",
  '"',
  "(",
  ")",
  "[",
  "]",
  "{",
  "}",
  "@",
  "*",
  "&",
  "%",
  "\u2054",
  "+",
  "<",
  "=",
  ">",
  "|",
  "~",
  "$",
  "\u2055",
  "\u2056",
  "\u2058",
  "\u2059",
  "\u205A",
  "\u205B",
  "\u205C",
  "\u205D",
  "\u205E",
  "\u2E00",
  "\u2E01",
  "\u2E02",
  "\u2E03",
  "\u2E04",
  "\u2E05",
  "\u2E06",
  "\u2E07",
  "\u2E08",
  "\u2E09",
  "\u2E0A",
  "\u2E0B",
  "\u2E0C",
  "\u2E0D",
  "\u2E0E",
  "\u2E0F",
  "\u2E10",
  "\u2E11",
  "\u2E12",
  "\u2E13",
  "\u2E14",
  "\u2E15",
  "\u2E16",
  "\u2E17",
  "\u2E1C",
  "\u2E1D",
  " ",
  "#"
];

// src/clean_inputs.ts
var modifier_map = {
  "none": null,
  "camelcase": camelCase,
  "pascalcase": titleCase,
  "snakecase": snakeCase,
  "kebabcase": kebabCase
};
function prep_clean_query(original_query, plugin) {
  let fixed_query = original_query;
  let setting_value = plugin.settings.preffered_casing;
  let modifier_func = modifier_map[setting_value];
  if (modifier_func) {
    fixed_query = modifier_func(fixed_query);
  }
  for (const index in KNOWN_BAD_CHARACTERS) {
    fixed_query = fixed_query.replaceAll(KNOWN_BAD_CHARACTERS[index], "");
  }
  return fixed_query;
}
function titleCase(str) {
  str = str.toLocaleLowerCase();
  let words = str.split(" ");
  for (let i = 0; i < words.length; i++) {
    words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1);
  }
  return words.join(" ");
}
function camelCase(str) {
  str = str.toLocaleLowerCase();
  let words = str.split(" ");
  for (let i = 0; i < words.length; i++) {
    if (i == 0) {
      continue;
    }
    words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1);
  }
  return words.join(" ");
}
function kebabCase(str) {
  str = str.replaceAll(" ", "-");
  while (str.contains("--")) {
    str.replace("--", "-");
  }
  return str;
}
function snakeCase(str) {
  str = str.replaceAll(" ", "_");
  while (str.contains("__")) {
    str.replace("__", "_");
  }
  return str;
}

// src/modal.ts
var QuickTagSelector = class extends import_obsidian.FuzzySuggestModal {
  constructor(plugin, gatherer, onChooseItemCallback, fileList) {
    super(plugin.app);
    this.plugin = plugin;
    this.gatherer = gatherer.retrieve_tags;
    this.settings = plugin.settings;
    this.fileList = fileList ? fileList : [];
    this.tag = "";
    this.onChooseItemCallback = onChooseItemCallback;
    this.inputListener = this.listenInput.bind(this);
    this.tagCache = [];
    this.new_tags_enabled = gatherer.get_new_tag_permission();
  }
  onOpen() {
    this.setPlaceholder("Select a tag");
    this.inputEl.addEventListener("keyup", this.inputListener);
    super.onOpen();
  }
  onClose() {
    this.inputEl.removeEventListener("keyup", this.inputListener);
    super.onClose();
  }
  listenInput(evt) {
    this.getSuggestions(this.inputEl.value);
  }
  getSuggestions(query) {
    let cleaned_query = prep_clean_query(query, this.plugin);
    let search = (0, import_obsidian.prepareFuzzySearch)(cleaned_query);
    let options = this.getItems();
    if (this.new_tags_enabled) {
      if (!/^[0-9]+$/.test(cleaned_query)) {
        options = options.concat(["#" + cleaned_query + " (new tag)"]);
      }
    }
    let result = [];
    for (const item in options) {
      const match = search(options[item]);
      if (match) {
        result.push({ "item": options[item], "match": match });
      }
    }
    return result;
  }
  getItems() {
    if (!this.gatherer) {
      new import_obsidian.Notice("Error: Could not find tags!");
      return [];
    }
    if (this.tagCache.length == 0) {
      this.tagCache = this.gatherer(this, this.fileList);
    }
    return this.tagCache;
  }
  getItemText(tag) {
    return tag;
  }
  async onChooseItem(result) {
    let cleaned_tag = SPECIAL_COMMANDS.includes(result) ? result : result.split(" ")[0];
    this.onChooseItemCallback(cleaned_tag);
  }
};
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(thisApp, onSubmit, message) {
    super(thisApp);
    this.onSubmit = onSubmit;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: this.message });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Yes").setCta().onClick(() => {
      this.close();
      this.onSubmit(true);
    })).addButton((btn) => btn.setButtonText("No").setCta().onClick(() => {
      this.close();
      this.onSubmit(false);
    }));
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/tag_gatherers.ts
var import_obsidian2 = require("obsidian");
var BaseGatherer = class {
  constructor() {
    this._new_tag_permission = true;
  }
  enable_new_tag_permission() {
    this._new_tag_permission = true;
  }
  disable_new_tag_permission() {
    this._new_tag_permission = false;
  }
  get_new_tag_permission() {
    return this._new_tag_permission;
  }
};
var AddTagList = class extends BaseGatherer {
  retrieve_tags(plugin, fileList) {
    let tagSettings = _getStarredTags(plugin.settings, "cut_in_line");
    let tag_array = tagSettings.map((e) => e.replace("#", "")).filter((e) => e).map((e) => "#" + e);
    if (!plugin.settings.all_tags) {
      return tag_array;
    }
    let tag_cache = getTagsFromAppCache();
    tag_cache.sort();
    tag_cache.forEach((tag) => {
      if (tag_array.indexOf(tag) == -1) {
        tag_array.push(tag);
      }
    });
    return tag_array;
  }
};
var TagsOnFiles = class extends BaseGatherer {
  constructor() {
    super(...arguments);
    this._new_tag_permission = false;
  }
  retrieve_tags(plugin, fileList) {
    let tag_array = [];
    this.tag_map = {};
    fileList.forEach((f) => {
      let cache = plugin.app.metadataCache.getFileCache(f);
      if (cache) {
        let new_tags = (0, import_obsidian2.parseFrontMatterTags)(cache.frontmatter);
        if (new_tags) {
          new_tags.map((e) => e.replace("#", "")).filter((e) => e).map((e) => "#" + e);
          new_tags.forEach((item) => {
            if (!(item in this.tag_map)) {
              this.tag_map[item] = 0;
            }
            this.tag_map[item] += 1;
          });
        }
      }
    });
    for (const item in this.tag_map) {
      let quantity = this.tag_map[item];
      if (quantity > 1) {
        tag_array.push(item + " (" + this.tag_map[item].toString() + " notes)");
      } else {
        tag_array.push(item);
      }
    }
    tag_array.push("REMOVE ALL");
    return tag_array;
  }
};
var NonStarredTags = class extends BaseGatherer {
  constructor() {
    super(...arguments);
    this._new_tag_permission = false;
  }
  retrieve_tags(plugin) {
    let tag_array = getTagsFromAppCache();
    let starredTags = _getStarredTags(plugin.settings);
    starredTags.forEach((t) => tag_array.remove(t));
    tag_array.sort();
    return tag_array;
  }
};
function _getStarredTags(settings, filter_key) {
  let results = [];
  settings.priorityTags.forEach((t) => {
    if (filter_key) {
      t[filter_key] ? results.push(t.tag_value) : null;
    } else {
      results.push(t.tag_value);
    }
  });
  return results;
}
function getTagsFromAppCache() {
  let results = [];
  for (const key in this.app.metadataCache.getTags()) {
    results.push(key);
  }
  return results;
}

// src/file_filters.ts
var import_obsidian3 = require("obsidian");
function getFilteredWithTag(fileList, tag) {
  if (SPECIAL_COMMANDS.includes(tag)) {
    return fileList;
  }
  let resultList = fileList.filter((file) => filterTag(file, tag) == true);
  return resultList;
}
function getFilteredWithoutTag(fileList, tag) {
  if (SPECIAL_COMMANDS.includes(tag)) {
    return fileList;
  }
  let resultList = fileList.filter((file) => filterTag(file, tag) == false);
  return resultList;
}
function filterTag(thisFile, tag) {
  let cache = this.app.metadataCache.getFileCache(thisFile);
  let existing_tags = (0, import_obsidian3.parseFrontMatterTags)(cache.frontmatter);
  if (existing_tags == null ? void 0 : existing_tags.includes(tag)) {
    return true;
  } else {
    return false;
  }
}
function onlyTaggableFiles(fileList) {
  let resultList = fileList.filter((file) => (file.extension ? true : false) == true && file.extension == "md");
  return resultList;
}

// src/utilities.ts
var tag_key = "tags";
var tag_cleanup = ["tag", "Tag", "Tags"];
function _getActiveFile() {
  let thisFile = this.app.workspace.getActiveFile();
  if (thisFile instanceof import_obsidian4.TFile) {
    return [thisFile];
  } else {
    new import_obsidian4.Notice("No file open!");
    return [];
  }
}
async function _addTag(thisFile, tag) {
  this.tag = _formatHashTag(tag);
  await _cleanFile(thisFile);
  await this.app.fileManager.processFrontMatter(thisFile, _addFrontMatterTag.bind(this));
}
function _addFrontMatterTag(frontmatter) {
  frontmatter = _collectExistingTags(frontmatter);
  frontmatter[tag_key] = frontmatter[tag_key].map((t) => _formatHashTag(t));
  frontmatter[tag_key].push(this.tag);
}
async function _removeTag(thisFile, tag) {
  this.tag = _formatHashTag(tag);
  await _cleanFile(thisFile);
  let processor = _getRemovalProcessor(tag);
  await this.app.fileManager.processFrontMatter(thisFile, processor.bind(this));
}
function _getRemovalProcessor(tag) {
  if (tag != "REMOVE ALL") {
    return _removeFrontMatterTag;
  } else {
    console.log("removing all tags.....");
    return _removeAllFrontMatterTags;
  }
}
function _removeFrontMatterTag(frontmatter) {
  frontmatter = _collectExistingTags(frontmatter);
  let tags = frontmatter[tag_key];
  tags = tags.map((t) => _formatHashTag(t));
  let indx = tags.indexOf(this.tag, 0);
  if (indx > -1) {
    tags.splice(indx, 1);
  }
  frontmatter[tag_key] = tags;
}
function _removeAllFrontMatterTags(frontmatter) {
  frontmatter[tag_key] = [];
}
function _toggleTags(files, input_tag) {
  let tag = _formatHashTag(input_tag);
  let tag_added = 0;
  let tag_removed = 0;
  for (let i = 0; i < files.length; i++) {
    let exists = filterTag(files[i], `#${tag}`);
    if (!exists) {
      _addTag(files[i], tag);
      tag_added++;
    } else {
      _removeTag(files[i], tag);
      tag_removed++;
    }
  }
  return [tag_added, tag_removed];
}
async function _addTagToMany(files, tag, plugin) {
  console.log("ADDING TAGS");
  await _apply_bulk_changes(files, tag, plugin, _addTag);
}
async function _removeTagFromMany(files, tag, plugin) {
  console.log("REMOVING TAGS");
  await _apply_bulk_changes(files, tag, plugin, _removeTag);
}
async function _apply_bulk_changes(files, tag, plugin, func) {
  let status_bar = plugin.addStatusBarItem();
  status_bar.createEl("span");
  let useStatusBar = false;
  if (files.length > WOAH_LOTS_OF_FILES) {
    new import_obsidian4.Notice("Processing " + files.length + " files... This might take a while. See status bar for progress.");
    useStatusBar = true;
  }
  for (let i = 0; i < files.length; i++) {
    if (useStatusBar) {
      status_bar.setText(`Processing ${tag}: ${i + 1}/${files.length}`);
    }
    await func(files[i], tag);
  }
  status_bar.remove();
}
async function _cleanFile(f) {
  let text = await this.app.vault.read(f);
  let modified = _cleanNoteContent(text);
  if (modified) {
    console.log(`fixing up broken parts of ${f.basename}'s yaml...`);
    await this.app.vault.modify(f, text);
  }
}
function _cleanNoteContent(content) {
  let modified = false;
  if (content[0] == "\n") {
    while (content[0] == "\n") {
      content = content.slice(1);
    }
    modified = true;
  }
  if (content.indexOf("---\n") == 0) {
    let matches = content.match(/---\s*\n?/g);
    if (matches && matches[1] != "---\n" && matches[1] != "---") {
      content = content.replace(matches[1], "---\n");
      modified = true;
    }
  }
  if (modified) {
    return content;
  } else {
    return false;
  }
}
function _formatHashTag(tag) {
  return tag.replace("#", "");
}
function _collectExistingTags(yml) {
  if (!yml.hasOwnProperty(tag_key) || yml[tag_key] === null) {
    yml[tag_key] = [];
  } else {
    yml[tag_key] = _conformToArray(yml[tag_key]);
  }
  let alternate_keys = tag_cleanup.filter((v) => Object.keys(yml).includes(v));
  for (let i = 0; i < alternate_keys.length; i++) {
    let otherTags = _conformToArray(yml[alternate_keys[i]]);
    otherTags.forEach((tag) => {
      !yml[tag_key].includes(tag) ? yml[tag_key].push(tag) : console.log(tag + " already exists");
    });
    delete yml[alternate_keys[i]];
  }
  for (let i = 0; i < yml[tag_key].length; i++) {
    yml[tag_key][i] = _formatHashTag(yml[tag_key][i]);
  }
  return yml;
}
function _conformToArray(input) {
  let converted_array = typeof input === "string" ? input.split(",").map((e) => e.trim()) : input;
  let separated_array = [];
  converted_array.forEach((str) => separated_array.push(str.split(" ")));
  let output = separated_array.flat(Infinity);
  return output ? output : [];
}
function selectTag(plugin, gatherer, notes) {
  let active_gatherer = gatherer ? gatherer : new AddTagList();
  let active_notes = notes ? notes : [];
  return new Promise((resolve) => {
    new QuickTagSelector(plugin, active_gatherer, (result) => {
      resolve(result);
    }, active_notes).open();
  });
}
function confirmationNotification(mode, tag, applicableFiles) {
  let notes = applicableFiles.length > 1 ? applicableFiles.length + " notes" : applicableFiles[0].basename;
  let tofrom = mode == "add" ? " added to " : " removed from ";
  if (tag == "REMOVE ALL") {
    new import_obsidian4.Notice("All tags removed from " + notes);
  } else {
    new import_obsidian4.Notice(tag + tofrom + notes);
  }
}
function dynamicToggleCommand(plugin, StarredTag) {
  let tag = StarredTag.tag_value.replace("#", "");
  let commandId = `quick-add-tag:${tag}`;
  let fullId = `quick-tagger:${commandId}`;
  let state = false;
  if (plugin.app.commands.findCommand(fullId)) {
    delete plugin.app.commands.commands[fullId];
    delete plugin.app.commands.editorCommands[fullId];
  } else {
    plugin.addCommand({
      id: commandId,
      name: `Toggle #${tag}`,
      callback: () => {
        toggleTagOnActive(plugin, tag);
      }
    });
    state = true;
  }
  return state;
}
function dynamicAddMenuItems(menu, files, plugin) {
  let starredTags = plugin.settings.priorityTags;
  let singleFile = files.length == 1;
  let singleFileTags = [];
  if (singleFile) {
    let tmp_gatherer = new TagsOnFiles();
    singleFileTags = tmp_gatherer.retrieve_tags(plugin, files);
  }
  let operation = singleFile ? toggleTagOnFile : addTagsDirectly;
  starredTags.forEach((t) => {
    if (t.right_click) {
      menu.addItem((item) => {
        let title = `Tag with ${t.tag_value}`;
        if (singleFile) {
          let state = singleFileTags.includes(t.tag_value);
          title = state ? `Remove ${t.tag_value}` : `Add ${t.tag_value}`;
        }
        item.setTitle(title).setIcon("tag").onClick(async () => {
          operation(plugin, files, t.tag_value);
        });
      });
    }
  });
}
async function addDialogs(mode, tag, quantity) {
  let verb = mode;
  let tofrom = mode == "add" ? " to " : " from ";
  let confirm = true;
  if (tag == "REMOVE ALL") {
    let msg = "This will delete all tags on the active note(s), are you sure?";
    confirm = await adjust_tag_dialog(msg);
    verb = "";
  }
  if (!confirm) {
    return confirm;
  }
  if (quantity && quantity > 1) {
    let msg = "You are about to " + verb + " " + tag + tofrom + quantity + " notes, are you sure?";
    confirm = await adjust_tag_dialog(msg);
  }
  return confirm;
}
async function adjust_tag_dialog(msg) {
  let confirm = false;
  await new Promise((resolve) => {
    new ConfirmModal(this.app, (result) => resolve(confirm = result), msg).open();
  });
  return confirm;
}
async function addTagsWithModal(plugin, files) {
  let tag = await selectTag(plugin, new AddTagList(), files);
  addTagsDirectly(plugin, files, tag);
}
async function addTagWithModal(plugin) {
  let currentFile = _getActiveFile();
  addTagsWithModal(plugin, currentFile);
}
async function removeTagsWithModal(plugin, files) {
  let tag = await selectTag(plugin, new TagsOnFiles(), files);
  await removeTagsDirectly(plugin, files, tag);
}
async function removeTagWithModal(plugin) {
  let currentFile = _getActiveFile();
  await removeTagsWithModal(plugin, currentFile);
}
function toggleTagOnActive(plugin, tag) {
  let file = _getActiveFile();
  toggleTagOnFile(plugin, file, tag);
}
function toggleTagOnFile(plugin, file, tag) {
  update_last_used_tag(plugin, tag);
  let tag_added = _toggleTags(file, tag);
  tag_added[0] ? confirmationNotification("add", tag, file) : confirmationNotification("remove", tag, file);
}
async function addTagsDirectly(plugin, files, tag) {
  let applicableFiles = getFilteredWithoutTag(files, tag);
  if (applicableFiles.length == 0) {
    new import_obsidian4.Notice("No file tags to change!");
    return;
  }
  let confirm = await addDialogs("add", tag, files.length);
  if (confirm) {
    update_last_used_tag(plugin, tag);
    await _addTagToMany(applicableFiles, tag.replace("#", ""), plugin).then(
      () => confirmationNotification("add", tag, applicableFiles)
    );
  }
}
async function removeTagsDirectly(plugin, files, tag) {
  let applicableFiles = getFilteredWithTag(files, tag);
  if (applicableFiles.length == 0) {
    new import_obsidian4.Notice("No file tags to change!");
    return;
  }
  let confirm = await addDialogs("remove", tag, applicableFiles.length);
  if (confirm) {
    update_last_used_tag(plugin, tag);
    await _removeTagFromMany(applicableFiles, tag.replace("#", ""), plugin).then(
      () => confirmationNotification("remove", tag, applicableFiles)
    );
  }
}
async function update_last_used_tag(plugin, tag) {
  plugin.settings.last_used_tag = tag;
  await plugin.saveSettings();
  let commandId = "repeat-last-tag";
  if (plugin.app.commands.findCommand(commandId)) {
    delete plugin.app.commands.commands[commandId];
    delete plugin.app.commands.editorCommands[commandId];
  }
  plugin.addCommand({
    id: commandId,
    name: `Toggle recently used tag (${tag})`,
    callback: () => {
      toggleTagOnActive(plugin, tag);
    }
  });
}

// src/main.ts
var DEFAULT_SETTINGS = {
  all_tags: true,
  preffered_casing: "None",
  priorityTags: [],
  last_used_tag: ""
};
var QuickTagPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    let starredTags = this.settings.priorityTags;
    starredTags.forEach((t) => {
      if (t.add_command) {
        dynamicToggleCommand(this, t);
      }
    });
    this._statusBarItem = new Array();
    this.redrawButtons();
    const addTagRibbonIcon = this.addRibbonIcon("tag", "Add tag to current note", async (evt) => {
      addTagWithModal(this);
    });
    const removeTagRibbonIcon = this.addRibbonIcon("x-square", "Remove tag from current note", (evt) => {
      removeTagWithModal(this);
    });
    this.addCommand({
      id: "quick-add-tag",
      name: "Add tag",
      callback: () => {
        addTagWithModal(this);
      }
    });
    this.addCommand({
      id: "quick-remove-tag",
      name: "Remove tag",
      callback: () => {
        removeTagWithModal(this);
      }
    });
    this.addCommand({
      id: "repeat-last-tag",
      name: `Toggle recently used tag (none)`,
      callback: () => {
        new import_obsidian5.Notice("ERROR: No recent tag, please assign a tag with Quick Tagger before using this command");
      }
    });
    this.registerEvent(
      this.app.workspace.on("files-menu", (menu, files) => {
        files = onlyTaggableFiles(files);
        if (files.length < 1) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Tag " + files.length + " files with...").setIcon("tag").onClick(() => {
            addTagsWithModal(this, files);
          });
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("files-menu", (menu, files) => {
        if (files.length < 1) {
          return;
        }
        dynamicAddMenuItems(menu, files, this);
      })
    );
    this.registerEvent(
      this.app.workspace.on("files-menu", (menu, files) => {
        files = onlyTaggableFiles(files);
        if (files.length < 1) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Remove Tag from " + files.length + " files...").setIcon("tag").onClick(() => {
            removeTagsWithModal(this, files);
          });
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        let thisFile = onlyTaggableFiles([file]);
        if (thisFile.length < 1) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Tag file with...").setIcon("tag").onClick(() => {
            addTagsWithModal(this, thisFile);
          });
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        let thisFile = onlyTaggableFiles([file]);
        if (thisFile.length < 1) {
          return;
        }
        dynamicAddMenuItems(menu, thisFile, this);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        let thisFile = onlyTaggableFiles([file]);
        if (thisFile.length < 1) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Remove Tag(s)...").setIcon("tag").onClick(() => {
            removeTagsWithModal(this, thisFile);
          });
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("search:results-menu", (menu, leaf) => {
        let files = [];
        leaf.dom.vChildren.children.forEach((e) => files.push(e.file));
        files = onlyTaggableFiles(files);
        if (files.length < 1) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Add Tag to " + files.length + " notes...").setIcon("tag").onClick(() => {
            addTagsWithModal(this, files);
          });
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("search:results-menu", (menu, leaf) => {
        let files = [];
        leaf.dom.vChildren.children.forEach((e) => files.push(e.file));
        files = onlyTaggableFiles(files);
        if (files.length < 1) {
          return;
        }
        dynamicAddMenuItems(menu, files, this);
      })
    );
    this.registerEvent(
      this.app.workspace.on("search:results-menu", (menu, leaf) => {
        let files = [];
        leaf.dom.vChildren.children.forEach((e) => files.push(e.file));
        files = onlyTaggableFiles(files);
        if (files.length < 1) {
          return;
        }
        menu.addItem((item) => {
          item.setTitle("Remove Tags from " + files.length + " notes...").setIcon("tag").onClick(() => {
            removeTagsWithModal(this, files);
          });
        });
      })
    );
    this.addSettingTab(new QuickTagSettingTab(this));
  }
  async onunload() {
    this.settings.last_used_tag = "";
    await this.saveSettings();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  redrawButtons() {
    if (this._statusBarItem) {
      this._statusBarItem.forEach((t) => t.remove());
    }
    let starredTags = this.settings.priorityTags;
    starredTags.forEach(
      (t) => {
        if (t.status_bar) {
          let item_to_add = this.addStatusBarItem();
          this._statusBarItem.push(item_to_add);
          item_to_add.classList.add("mod-clickable");
          item_to_add.setText(t.tag_value);
          item_to_add.setAttribute("aria-label", `Toggle #${t.tag_value} on active note`);
          item_to_add.setAttribute("aria-label-position", "top");
          item_to_add.addEventListener("click", async () => {
            toggleTagOnActive(this, t.tag_value);
          });
        }
      }
    );
  }
};
var QuickTagSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.app = plugin.app;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("Use all tags").setDesc("If disabled, only Starred Tags will be shown in the tag selection dialog.").addToggle((toggle) => toggle.setValue(this.plugin.settings.all_tags).onChange(async (value) => {
      this.plugin.settings.all_tags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Preferred tag case").setDesc('Helper to replace spaces in input with a preffered tag style. "None" will just remove invalid characters.').addDropdown((dropdown) => dropdown.addOption("none", "None").addOption("camelcase", "applyCamelCase").addOption("pascalcase", "ApplyPascalCase").addOption("snakecase", "apply_snake_case").addOption("kebabcase", "apply-kebab-case").setValue(this.plugin.settings.preffered_casing).onChange(async (value) => {
      this.plugin.settings.preffered_casing = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h1", { text: "Starred tags" });
    containerEl.createEl("h2", "hello");
    const starredDiv = containerEl.createDiv();
    this.drawPriorityTags(starredDiv);
    new import_obsidian5.Setting(containerEl).addButton((btn) => btn.setTooltip("Add a starred tag").onClick(async () => {
      let thisTag = await selectTag(this.plugin, new NonStarredTags());
      this.plugin.settings.priorityTags.push({
        tag_value: thisTag,
        cut_in_line: true,
        add_command: false,
        status_bar: false,
        right_click: false
      });
      await this.plugin.saveSettings();
      this.drawPriorityTags(starredDiv);
    }).setIcon("plus"));
  }
  drawPriorityTags(div) {
    div.empty();
    const priorityTags = this.plugin.settings.priorityTags;
    new import_obsidian5.Setting(div).addButton((btn) => {
      btn.setIcon("star");
      let msg = "The first toggle on a starred tag moves it to the top of the list when selecting a tag for your notes.";
      btn.onClick(() => new import_obsidian5.Notice(msg, 6e3));
      btn.setTooltip(msg);
    }).addButton((btn) => {
      btn.setIcon("chevron-right-square");
      let msg = "The second toggle on a starred tag adds a command for it so you can create a hotkey, etc.";
      btn.onClick(() => new import_obsidian5.Notice(msg, 6e3));
      btn.setTooltip(msg);
    }).addButton((btn) => {
      btn.setIcon("martini");
      let msg = "The third toggle on a starred tag adds a button for it to the status bar.";
      btn.onClick(() => new import_obsidian5.Notice(msg, 6e3));
      btn.setTooltip(msg);
    }).addButton((btn) => {
      btn.setIcon("mouse-pointer-click");
      let msg = "The fourth toggle on a starred tag adds it to the context menu.";
      btn.onClick(() => new import_obsidian5.Notice(msg, 6e3));
      btn.setTooltip(msg);
    }).addButton((btn) => {
      btn.setIcon("up-arrow-with-tail");
      let msg = "The up arrow button moves the starred tag up on the starred tag list. This affects the order it's displayed in the tag selection dialog.";
      btn.onClick(() => new import_obsidian5.Notice(msg, 6e3));
      btn.setTooltip(msg);
    }).addButton((btn) => {
      btn.setIcon("down-arrow-with-tail");
      let msg = "The down arrow button moves the starred tag down on the starred tag list. This affects the order it's displayed in the tag selection dialog.";
      btn.onClick(() => new import_obsidian5.Notice(msg, 6e3));
      btn.setTooltip(msg);
    }).addButton((btn) => {
      btn.setIcon("trash");
      let msg = "The trash can button removes the starred tag from the starred list.";
      btn.onClick(() => new import_obsidian5.Notice(msg, 6e3));
      btn.setTooltip(msg);
    }).nameEl.setText("Starred tags get special treatment. Click or hover over these buttons for more details \u{1F449}");
    priorityTags.forEach((tag, i) => {
      const s = new import_obsidian5.Setting(div).addToggle((toggle) => {
        toggle.setValue(tag.cut_in_line).onChange(async (value) => {
          tag.cut_in_line = value;
          await this.plugin.saveSettings();
          new import_obsidian5.Notice(tag.cut_in_line ? `Added ${tag.tag_value} to priority section of selector dialog` : `Removed ${tag.tag_value} from priority section of selector dialog`);
        });
        toggle.setTooltip("Show first in tag selection dialog");
      }).addToggle((toggle) => {
        toggle.setValue(tag.add_command).onChange(async (value) => {
          tag.add_command = value;
          await this.plugin.saveSettings();
          dynamicToggleCommand(this.plugin, tag);
          new import_obsidian5.Notice(tag.add_command ? `Added ${tag.tag_value} command` : `Removed ${tag.tag_value} command`);
        });
        toggle.setTooltip("Add command for this tag");
      }).addToggle((toggle) => {
        toggle.setValue(tag.status_bar).onChange(async (value) => {
          tag.status_bar = value;
          await this.plugin.saveSettings();
          new import_obsidian5.Notice(tag.status_bar ? `Added ${tag.tag_value} button to status bar` : `Removed ${tag.tag_value} button from status bar`);
          this.plugin.redrawButtons();
        });
        toggle.setTooltip("Add button to status bar");
      }).addToggle((toggle) => {
        toggle.setValue(tag.right_click).onChange(async (value) => {
          tag.right_click = value;
          await this.plugin.saveSettings();
          new import_obsidian5.Notice(tag.right_click ? `Added ${tag.tag_value} to right-click menu` : `Removed ${tag.tag_value} from right-click menu`);
        });
        toggle.setTooltip("Add context menu entry");
      }).addButton((button) => {
        button.onClick(async () => {
          const oldTag = priorityTags[i - 1];
          priorityTags[i - 1] = tag;
          priorityTags[i] = oldTag;
          this.drawPriorityTags(div);
          await this.plugin.saveSettings();
          this.plugin.redrawButtons();
        });
        button.setIcon("up-arrow-with-tail");
        button.setTooltip("Move Starred tag up");
        if (i === 0) {
          button.setDisabled(true);
        }
      }).addButton((button) => {
        button.onClick(async () => {
          const oldTag = priorityTags[i + 1];
          priorityTags[i + 1] = tag;
          priorityTags[i] = oldTag;
          this.drawPriorityTags(div);
          await this.plugin.saveSettings();
          this.plugin.redrawButtons();
        });
        button.setIcon("down-arrow-with-tail");
        button.setTooltip("Move Starred tag down");
        if (i === priorityTags.length - 1) {
          button.setDisabled(true);
        }
      }).addButton((btn) => {
        btn.onClick(async () => {
          priorityTags.remove(tag);
          await this.plugin.saveSettings();
          this.drawPriorityTags(div);
        });
        btn.setIcon("trash");
        btn.setTooltip("Remove this tag");
      });
      s.nameEl.createEl("div", { text: tag.tag_value });
    });
  }
};


/* nosourcemap */